````markdown
# Query Execution Engine – OpenObserve Assistant  
`/execution/query_execution_engine.md`

---

## 1. Overview

The Query Execution Engine is responsible for executing SQL or VRL queries generated by the LLM against OpenObserve’s backend APIs. It ensures result delivery, timeout handling, and safe execution for user-initiated queries across MVP and production phases.

---

## 2. Execution Phases

### 🔹 MVP Phase

- Queries are executed via backend-issued `curl` requests to OpenObserve API
- Token-based or session-auth headers passed directly
- Response is returned as raw JSON and parsed internally

### 🔹 Production Phase

- Queries are executed via direct `POST` requests to OpenObserve’s search API
- Supports both SQL (`/api/{org}/search/sql`) and VRL (`/api/{org}/search/logs`) endpoints
- Future enhancements may introduce streaming or batched result handling

---

## 3. Input Contract

```json
{
  "query_type": "sql" | "vrl",
  "query_text": "SELECT count(*) FROM errors WHERE status_code >= 500",
  "index": "walmart_web_analytics",
  "deployment": "anivia",
  "time_range": {
    "from": "2025-08-01T00:00:00Z",
    "to": "2025-08-01T00:15:00Z"
  },
  "auth_token": "Bearer eyJ..."
}
````

---

## 4. Timeout & Result Limits

| Parameter      | Value                                                  |
| -------------- | ------------------------------------------------------ |
| Timeout        | ⏱ 15 seconds (both MVP and prod)                       |
| Max rows       | 📊 50 results max                                      |
| Time range cap | ⏳ None (default to 15 min)                             |
| User messaging | If row limit exceeded, prompt user to group by a field |

---

## 5. Error Handling & Fallbacks

| Scenario         | Behavior                                               |
| ---------------- | ------------------------------------------------------ |
| 5xx server error | Retry once with same payload (no backoff)              |
| Timeout          | Show UI: “Query execution failed: request timed out”   |
| 4xx error        | Show UI: “Query execution failed: invalid request”     |
| Empty result     | Show UI card: “No data found in selected time range”   |
| Malformed query  | Bubble error to UI with context (e.g., “Syntax error”) |

---

## 6. Auth & Security

* Auth is passed via `auth_token` or session cookie
* All outbound requests must:

  * Use HTTPS
  * Mask `Authorization` in logs
* Only read-only scope tokens are accepted by the engine

---

## 7. Output Format

On success:

```json
{
  "status": "ok",
  "rows": [
    {"status_code": "500", "count": 244},
    {"status_code": "404", "count": 92}
  ],
  "fields": ["status_code", "count"],
  "execution_time_ms": 210,
  "query_id": "q_839bc1f"
}
```

On failure:

```json
{
  "status": "error",
  "error_type": "timeout" | "invalid_request" | "internal_error",
  "message": "Query execution failed: request timed out",
  "query_id": "q_839bc1f"
}
```

---

## 8. UI Integration

* Results from OpenObserve are passed to the LLM before rendering.
* The LLM uses the query intent and returned data to generate a natural-language summary. For example:

  * If the user asks for “top 5 error codes”, the LLM selects top 5 from `rows[]` and formats them as a list.
  * If the user asks “how did ATC error rate change?”, the LLM compares rows by time and generates a sentence like:
    *“ATC error rate increased by 0.1%, from 2.1% yesterday to 2.2% today.”*
* The UI renders:

  * 🧾 A natural-language summary from the LLM (primary view)
  * 📊 An optional expandable table of raw rows for transparency
* Execution errors result in:

  * Toast notification
  * Embedded error card with summary (e.g., “Query failed due to timeout”)
* All query metadata (`query_id`, `execution_time_ms`, `field_count`) is logged to telemetry backend

---

```
```
