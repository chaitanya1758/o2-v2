````markdown
# Query Execution Engine â€“ OpenObserve Assistant  
`/execution/query_execution_engine.md`

---

## 1. Overview

The Query Execution Engine is responsible for executing SQL or VRL queries generated by the LLM against OpenObserveâ€™s backend APIs. It ensures result delivery, timeout handling, and safe execution for user-initiated queries across MVP and production phases.

---

## 2. Execution Phases

### ğŸ”¹ MVP Phase

- Queries are executed via backend-issued `curl` requests to OpenObserve API
- Token-based or session-auth headers passed directly
- Response is returned as raw JSON and parsed internally

### ğŸ”¹ Production Phase

- Queries are executed via direct `POST` requests to OpenObserveâ€™s search API
- Supports both SQL (`/api/{org}/search/sql`) and VRL (`/api/{org}/search/logs`) endpoints
- Future enhancements may introduce streaming or batched result handling

---

## 3. Input Contract

```json
{
  "query_type": "sql" | "vrl",
  "query_text": "SELECT count(*) FROM errors WHERE status_code >= 500",
  "index": "walmart_web_analytics",
  "deployment": "anivia",
  "time_range": {
    "from": "2025-08-01T00:00:00Z",
    "to": "2025-08-01T00:15:00Z"
  },
  "auth_token": "Bearer eyJ..."
}
````

---

## 4. Timeout & Result Limits

| Parameter      | Value                                                  |
| -------------- | ------------------------------------------------------ |
| Timeout        | â± 15 seconds (both MVP and prod)                       |
| Max rows       | ğŸ“Š 50 results max                                      |
| Time range cap | â³ None (default to 15 min)                             |
| User messaging | If row limit exceeded, prompt user to group by a field |

---

## 5. Error Handling & Fallbacks

| Scenario         | Behavior                                               |
| ---------------- | ------------------------------------------------------ |
| 5xx server error | Retry once with same payload (no backoff)              |
| Timeout          | Show UI: â€œQuery execution failed: request timed outâ€   |
| 4xx error        | Show UI: â€œQuery execution failed: invalid requestâ€     |
| Empty result     | Show UI card: â€œNo data found in selected time rangeâ€   |
| Malformed query  | Bubble error to UI with context (e.g., â€œSyntax errorâ€) |

---

## 6. Auth & Security

* Auth is passed via `auth_token` or session cookie
* All outbound requests must:

  * Use HTTPS
  * Mask `Authorization` in logs
* Only read-only scope tokens are accepted by the engine

---

## 7. Output Format

On success:

```json
{
  "status": "ok",
  "rows": [
    {"status_code": "500", "count": 244},
    {"status_code": "404", "count": 92}
  ],
  "fields": ["status_code", "count"],
  "execution_time_ms": 210,
  "query_id": "q_839bc1f"
}
```

On failure:

```json
{
  "status": "error",
  "error_type": "timeout" | "invalid_request" | "internal_error",
  "message": "Query execution failed: request timed out",
  "query_id": "q_839bc1f"
}
```

---

## 8. UI Integration

* Results from OpenObserve are passed to the LLM before rendering.
* The LLM uses the query intent and returned data to generate a natural-language summary. For example:

  * If the user asks for â€œtop 5 error codesâ€, the LLM selects top 5 from `rows[]` and formats them as a list.
  * If the user asks â€œhow did ATC error rate change?â€, the LLM compares rows by time and generates a sentence like:
    *â€œATC error rate increased by 0.1%, from 2.1% yesterday to 2.2% today.â€*
* The UI renders:

  * ğŸ§¾ A natural-language summary from the LLM (primary view)
  * ğŸ“Š An optional expandable table of raw rows for transparency
* Execution errors result in:

  * Toast notification
  * Embedded error card with summary (e.g., â€œQuery failed due to timeoutâ€)
* All query metadata (`query_id`, `execution_time_ms`, `field_count`) is logged to telemetry backend

---

```
```
